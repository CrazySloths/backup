<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use App\Models\User;
use App\Services\AuthSecurityService;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Validator;
use Illuminate\Support\Facades\Session;

class CitizenAuthController extends Controller
{
    protected $authSecurityService;

    public function __construct(AuthSecurityService $authSecurityService)
    {
        $this->authSecurityService = $authSecurityService;
    }

    /**
     * Show citizen registration form
     */
    public function showRegistrationForm()
    {
        return view('citizen.auth.register');
    }

    /**
     * Handle citizen registration
     */
    public function register(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'first_name' => 'required|string|max:255',
            'middle_name' => 'nullable|string|max:255',
            'last_name' => 'required|string|max:255',
            'name' => 'nullable|string|max:500', // Auto-generated from name components
            'email' => 'required|string|email|max:255|unique:users',
            'password' => 'required|string|min:8|confirmed',
            'phone_number' => 'required|string|regex:/^09[0-9]{9}$/',
            'region' => 'required|string|max:100',
            'city' => 'required|string|max:100',
            'barangay' => 'required|string|max:100',
            'street_address' => 'required|string|max:255',
            'address' => 'required|string|max:500', // This will be auto-generated from the components
            'date_of_birth' => 'required|date|before:today',
        ]);

        if ($validator->fails()) {
            return back()->withErrors($validator)->withInput();
        }

        // Create user with verification flags set to false initially
        $user = User::create([
            'first_name' => $request->first_name,
            'middle_name' => $request->middle_name,
            'last_name' => $request->last_name,
            'name' => $request->name, // Auto-generated by JavaScript
            'email' => $request->email,
            'password' => Hash::make($request->password),
            'role' => 'citizen',
            'phone_number' => $request->phone_number,
            'region' => $request->region,
            'city' => $request->city,
            'barangay' => $request->barangay,
            'street_address' => $request->street_address,
            'address' => $request->address,
            'date_of_birth' => $request->date_of_birth,
            'is_verified' => false, // Account verified only after completing security verifications
            'verified_at' => null,
            // Security verification flags - all start as false
            'email_verified' => false,
            'phone_verified' => false,
            'two_factor_enabled' => false,
        ]);

        // Send email verification only (SMS will be sent after email verification)
        $emailSent = $this->authSecurityService->sendEmailVerification($user);

        // Store user ID in session for verification process
        Session::put('verification_user_id', $user->id);
        Session::put('verification_step', 'email_pending');

        if (!$emailSent) {
            return back()->withErrors([
                'verification' => 'Failed to send email verification. Please try again.'
            ])->withInput();
        }

        return redirect()->route('citizen.auth.verify')
            ->with('success', 'Account created! Please check your email to verify your account. Phone verification will be available after email verification.');
    }

    /**
     * Show login form (admin or citizen context)
     */
    public function showLoginForm(Request $request)
    {
        // Check if this is admin login based on route or URL
        $isAdminLogin = str_contains($request->url(), '/admin') || $request->route()->getName() === 'admin.login';
        
        if ($isAdminLogin) {
            return view('citizen.auth.login', ['isAdminLogin' => true]);
        }
        
        return view('citizen.auth.login', ['isAdminLogin' => false]);
    }

    /**
     * Handle authentication for both citizen and admin
     */
    public function login(Request $request)
    {
        $credentials = $request->validate([
            'email' => 'required|email',
            'password' => 'required',
        ]);

        if (Auth::attempt($credentials)) {
            $request->session()->regenerate();

            $user = Auth::user();
            
            // Check current route to determine where to redirect
            $currentRoute = $request->route()->getName();
            
            if ($currentRoute === 'admin.login.submit' || str_contains($request->url(), '/admin')) {
                // Admin login attempt
                if ($user->isAdmin()) {
                    return redirect()->intended('/admin/facilities');
                } else {
                    Auth::logout();
                    return back()->withErrors([
                        'email' => 'Access denied. Admin credentials required for administrative access.',
                    ]);
                }
            } else {
                // Citizen login attempt
                if ($user->isCitizen()) {
                    return redirect()->intended('citizen/dashboard');
                } elseif ($user->isAdmin()) {
                    // Admin trying to access citizen portal - redirect to admin
                    return redirect()->route('admin.login')->with('info', 'Redirected to admin portal.');
                }
            }
        }

        return back()->withErrors([
            'email' => 'The provided credentials do not match our records.',
        ]);
    }

    /**
     * Handle logout for both admin and citizen users
     */
    public function logout(Request $request)
    {
        $user = Auth::user();
        $isAdmin = $user && $user->isAdmin();
        
        Auth::logout();
        $request->session()->invalidate();
        $request->session()->regenerateToken();

        // Redirect based on user role
        if ($isAdmin) {
            return redirect()->route('admin.login')->with('success', 'You have been logged out successfully.');
        } else {
            return redirect()->route('citizen.login')->with('success', 'You have been logged out successfully.');
        }
    }

    // ========================================
    // VERIFICATION METHODS
    // ========================================

    /**
     * Show verification form
     */
    public function showVerificationForm()
    {
        $userId = Session::get('verification_user_id');
        if (!$userId) {
            return redirect()->route('citizen.register')
                ->withErrors(['verification' => 'Verification session expired. Please register again.']);
        }

        $user = User::find($userId);
        if (!$user) {
            return redirect()->route('citizen.register')
                ->withErrors(['verification' => 'User not found. Please register again.']);
        }

        return view('citizen.auth.verify', compact('user'));
    }

    /**
     * Handle email verification
     */
    public function verifyEmail(Request $request)
    {
        $token = $request->get('token');
        $userId = Session::get('verification_user_id');

        if (!$userId || !$token) {
            return redirect()->route('citizen.register')
                ->withErrors(['verification' => 'Invalid verification link.']);
        }

        $user = User::find($userId);
        if (!$user) {
            return redirect()->route('citizen.register')
                ->withErrors(['verification' => 'User not found.']);
        }

        if (!$this->authSecurityService->canProceedWithVerification($user)) {
            return redirect()->route('citizen.auth.verify')
                ->withErrors(['verification' => 'Account is temporarily locked due to failed attempts. Please try again later.']);
        }

        if ($user->verifyEmail($token)) {
            // Email verified successfully, now send SMS verification
            $smsSent = $this->authSecurityService->sendSmsVerification($user);
            
            // Update verification step
            Session::put('verification_step', 'sms_pending');
            
            $this->checkVerificationCompletion($user);
            
            if ($smsSent) {
                return redirect()->route('citizen.auth.verify')
                    ->with('success', 'Email verified successfully! We\'ve sent a verification code to your phone number.');
            } else {
                return redirect()->route('citizen.auth.verify')
                    ->with('success', 'Email verified successfully!')
                    ->withErrors(['sms' => 'Failed to send SMS verification. Please use the "Resend SMS" button.']);
            }
        }

        return redirect()->route('citizen.auth.verify')
            ->withErrors(['email_verification' => 'Invalid verification token.']);
    }

    /**
     * Handle phone verification
     */
    public function verifyPhone(Request $request)
    {
        $request->validate([
            'phone_code' => 'required|string|size:6'
        ]);

        $userId = Session::get('verification_user_id');
        if (!$userId) {
            return redirect()->route('citizen.register')
                ->withErrors(['verification' => 'Verification session expired.']);
        }

        $user = User::find($userId);
        if (!$user) {
            return redirect()->route('citizen.register')
                ->withErrors(['verification' => 'User not found.']);
        }

        if (!$this->authSecurityService->canProceedWithVerification($user)) {
            return response()->json([
                'success' => false,
                'message' => 'Account is temporarily locked due to failed attempts. Please try again later.'
            ]);
        }

        if ($user->verifyPhone($request->phone_code)) {
            $this->checkVerificationCompletion($user);
            return response()->json([
                'success' => true,
                'message' => 'Phone verified successfully!'
            ]);
        }

        return response()->json([
            'success' => false,
            'message' => 'Invalid verification code or code has expired.'
        ]);
    }

    /**
     * Resend email verification
     */
    public function resendEmailVerification()
    {
        $userId = Session::get('verification_user_id');
        if (!$userId) {
            return response()->json([
                'success' => false,
                'message' => 'Verification session expired.'
            ]);
        }

        $user = User::find($userId);
        if (!$user || $user->hasVerifiedEmail()) {
            return response()->json([
                'success' => false,
                'message' => 'Email already verified or user not found.'
            ]);
        }

        if (!$this->authSecurityService->canProceedWithVerification($user)) {
            return response()->json([
                'success' => false,
                'message' => 'Account is temporarily locked. Please try again later.'
            ]);
        }

        $sent = $this->authSecurityService->sendEmailVerification($user);
        
        return response()->json([
            'success' => $sent,
            'message' => $sent ? 'Email verification sent!' : 'Failed to send email. Please try again.'
        ]);
    }

    /**
     * Resend SMS verification
     */
    public function resendSmsVerification()
    {
        $userId = Session::get('verification_user_id');
        if (!$userId) {
            return response()->json([
                'success' => false,
                'message' => 'Verification session expired.'
            ]);
        }

        $user = User::find($userId);
        if (!$user || $user->hasVerifiedPhone()) {
            return response()->json([
                'success' => false,
                'message' => 'Phone already verified or user not found.'
            ]);
        }

        if (!$this->authSecurityService->canProceedWithVerification($user)) {
            return response()->json([
                'success' => false,
                'message' => 'Account is temporarily locked. Please try again later.'
            ]);
        }

        $sent = $this->authSecurityService->sendSmsVerification($user);
        
        return response()->json([
            'success' => $sent,
            'message' => $sent ? 'SMS verification sent!' : 'Failed to send SMS. Please try again.'
        ]);
    }

    /**
     * Check if verification is complete and redirect accordingly
     */
    protected function checkVerificationCompletion(User $user)
    {
        if ($user->hasCompletedRequiredVerifications()) {
            // Mark account as verified
            $user->update([
                'is_verified' => true,
                'verified_at' => now(),
                'last_security_check' => now(),
            ]);

            // Clear verification session
            Session::forget(['verification_user_id', 'verification_step']);

            // Log the user in
            Auth::login($user);
        }
    }

    /**
     * Show 2FA setup page (optional step)
     */
    public function showTwoFactorSetup()
    {
        if (!Auth::check()) {
            return redirect()->route('citizen.login');
        }

        $user = Auth::user();
        if ($user->hasTwoFactorEnabled()) {
            return redirect()->route('citizen.dashboard');
        }

        $secret = $this->authSecurityService->generateTotpSecret($user);
        $qrCodeUrl = $this->authSecurityService->generateQrCodeUrl($user);

        return view('citizen.auth.setup-2fa', compact('secret', 'qrCodeUrl'));
    }

    /**
     * Enable 2FA after verification
     */
    public function enableTwoFactor(Request $request)
    {
        $request->validate([
            'verification_code' => 'required|string|size:6'
        ]);

        if (!Auth::check()) {
            return response()->json([
                'success' => false,
                'message' => 'Authentication required.'
            ]);
        }

        $user = Auth::user();
        
        if ($this->authSecurityService->enableTwoFactor($user, $request->verification_code)) {
            return response()->json([
                'success' => true,
                'message' => '2FA enabled successfully!',
                'recovery_codes' => $user->two_factor_recovery_codes
            ]);
        }

        return response()->json([
            'success' => false,
            'message' => 'Invalid verification code.'
        ]);
    }
}